import{n as D,p as at,t as P,c as fe,a as Nt,g as qt,i as me,f as lt,b as Et,o as xt,d as tt,u as v,e as cs,m as it,h as Pt,j as _t,k as E,l as L,q as Rt,r as rs,s as Lt,v as Be,J as is,w as ls,x as ft,y as ds,z as et,P as Y,A as us,B as st,C as Ht,D as St,S as Ft,$ as ne,E as hs,F as ps,G as fs,H as ms,I as Jt,K as Kt,R as ge,L as Vt,M as gs,N as ve,O as vs,Q as Ge,T as bt,U as Ss,V as Qe,W as $e,X as Cs,Y as Te,Z as zt,_ as ys,a0 as pt,a1 as Bt,a2 as Ye,a3 as ws,a4 as Rs,a5 as Es,a6 as xs,a7 as Ps}from"./@alova-Cz8T9Pb0.js";import{b as _s,r as Ms,E as se,s as Fe,m as bs,w as Ke}from"./@vue-kKykbxn7.js";let Se={autoHitCache:"global",ssr:gs};const Ot="color: black; font-size: 12px; font-weight: bolder";var Us=(t,e,s,n)=>{const a=console,i=(...d)=>console.log(...d),{url:r}=e,l=s===Ft,f="\x1B[42m%s\x1B[49m",g="\x1B[32m%s\x1B[39m",o=` [HitCache]${r} `,c=()=>Array(L(o)+1).join("^");Se.ssr?(i(f,o),i(g," Cache ",t),i(g," Mode  ",s),l&&i(g," Tag   ",n),i(g,c())):(a.groupCollapsed?a.groupCollapsed("%cHitCache","padding: 2px 6px; background: #c4fcd3; color: #53b56d;",r):i(f,o),i("%c[Cache]",Ot,t),i("%c[Mode]",Ot,s),l&&i("%c[Tag]",Ot,n),i("%c[Method]",Ot,e),a.groupEnd?a.groupEnd():i(g,c()))};const oe=t=>`hss.${t}`,Je="hsr.",ce=t=>Je+t,Gt="$$hsrs",Xe="__$<>$__",re=(t,e)=>{t[e]=0},Dt=async(t,e,s,n,a,i,r)=>{if(n>Kt()&&s){const l=Jt(t,e);if(await a.set(l,Et([s,n===1/0?v:n,r],Boolean)),i){const f={},g=[];lt(i,d=>{const p=ft(d,ge),M=p?d.source+(d.flags?Xe+d.flags:""):d;M&&(p&&!f[M]&&at(g,M),re(f,p?ce(M):oe(M)))});const o=it(xt(f),async d=>{const p=await a.get(d)||{};re(p,l),await a.set(d,p)}),c=async()=>{if(L(g)){const d=await a.get(Gt)||[];at(d,...g),await a.set(Gt,d)}};await Y.all([...o,c()])}}},ie=async(t,e,s)=>{const n=Jt(t,e);await s.remove(n)},Ze=async(t,e,s,n)=>{const a=await s.get(Jt(t,e));if(a){const[i,r,l]=a;if(l===n&&(!r||r>Kt()))return a;await ie(t,e,s)}},Tt=async(t,e,s,n)=>{const a=await Ze(t,e,s,n);return a?a[0]:v},Le=async t=>Y.all(t.map(e=>e.clear())),Ts=async(t,e,s)=>{const n=`${e}`,a={},i=oe(t);a[i]=await s.get(i);let r;if(e){const o=oe(n);a[o]=await s.get(o),r=await s.get(Gt);const c=[];r&&L(r)&&(lt(r,d=>{const[p,M]=d.split(Xe);D(ge,p,M).test(n)&&at(c,d)}),await Y.all(it(c,async d=>{const p=ce(d);a[p]=await s.get(p)})))}const l=async o=>{try{await s.remove(o);for(const c in a){const d=a[c];d&&_t(d,o)}}catch{}},f={};await Y.all(it(xt(a),async o=>{const c=a[o];if(c){const d=[];for(const p in c)f[p]||(re(f,p),at(d,l(p)));await Y.all(d)}}));const g=L(r||[]);await Y.all(it(xt(a),async o=>{const c=a[o];c&&(L(xt(c))?await s.set(o,c):(await s.remove(o),o.includes(Je)&&r&&(r=Et(r,d=>ce(d)!==o))))})),g!==L(r||[])&&await s.set(Gt,r)};var Fs=t=>{const{data:e,config:s}=t,n={...s},{headers:a={},params:i={}}=n,r=St(t);n.headers={...a},n.params={...i};const l=D(nt,t.type,r,t.url,n,e);return Vt(l,{...t,config:n})};const le=async(t,{policy:e="all"}={})=>{if(t&&t.key){const{id:s,l1Cache:n,l2Cache:a}=St(t),i=st(t),{f:r,c:l,s:f,e:g,t:o}=Ht(t);if(l)return r();let c=e!=="l2"?await Tt(s,i,n):v;return e==="l2"?c=await Tt(s,i,a,o):e==="all"&&!c&&f&&g(Ft)>Kt()&&(c=await Tt(s,i,a,o)),c}},ae=async(t,e,{policy:s="all"}={})=>{const a=(Pt(t)?t:[t]).map(async i=>{const{hitSource:r}=i,{id:l,l1Cache:f,l2Cache:g}=St(i),o=st(i),{e:c,s:d,t:p,c:M}=Ht(i);if(M)return;let H=e;if(tt(e)){let W=s!=="l2"?await Tt(l,o,f):v;if((s==="l2"||s==="all"&&!W&&d&&c(Ft)>Kt())&&(W=await Tt(l,o,g,p)),H=e(W),H===v)return}return Y.all([s!=="l2"&&Dt(l,o,H,c(ve),f,r),s==="l2"||s==="all"&&d?Dt(l,o,H,c(Ft),g,r,p):v])});return Y.all(a)},Ks=async t=>{if(!t){await Y.all([Le(Qt),Le($t)]);return}const s=(Pt(t)?t:[t]).map(n=>{const{id:a,l1Cache:i,l2Cache:r}=St(n),{c:l}=Ht(n);if(l)return;const f=st(n);return Y.all([ie(a,f,i),ie(a,f,r)])});await Y.all(s)},Ls=async t=>{const{autoHitCache:e}=Se,{l1Cache:s,l2Cache:n}=St(t),a=st(t),{name:i}=qt(t),r={global:[...Qt,...$t],self:[s,n],close:[]}[e];r&&L(r)&&await Y.all(it(r,l=>Ts(a,i,l)))},De={};function Ds(t,e){let s=P,n;const a=D(Y,r=>{n=r});return{abort:()=>{Rt(a,r=>r&&r.abort())},onDownload:r=>{Rt(a,l=>l&&l.onDownload&&l.onDownload(r))},onUpload:r=>{Rt(a,l=>l&&l.onUpload&&l.onUpload(r))},response:async()=>{const{beforeRequest:r=et,responded:l,requestAdapter:f,cacheLogger:g}=us(t),o=st(t),{s:c,t:d,m:p,e:M}=Ht(t),{id:H,l1Cache:W,l2Cache:w,snapshots:b}=St(t),{cacheFor:ot}=qt(t),{hitSource:z}=t;let Z=await(tt(ot)?ot():e?v:Tt(H,o,W));if(p===Ft&&!Z&&!e){const K=await Ze(H,o,w,d);if(K){const[X,j]=K;await Dt(H,o,X,j,W,z),Z=X}}const A=Fs(t);await r(A);const{baseURL:I,url:R,type:_,data:y}=A,{params:U={},headers:ct={},transform:V=ne,shareRequest:mt}=qt(A),k=De[H]=De[H]||{},G=A.data,S=hs(G);let T=S?v:k[o],q=ne,x=v,Q=et;if(tt(l))q=l;else if(me(l)){const{onSuccess:K,onError:X,onComplete:j}=l;q=tt(K)?K:q,x=tt(X)?X:x,Q=tt(j)?j:Q}if(Z!==v)return n(),A.fromCache=P,ps(g,Us)(Z,A,p,d),Q(A),Z;if(s=E,!mt||!T){const K=f({url:fs(I,R,U),type:_,data:y,headers:ct},A);T=k[o]=K}n(T);const J=async(K,X,j=P)=>{const ht=await K,dt=await V(ht,X||{});b.save(t);try{await Ls(A)}catch{}if((!G||!S)&&j)try{await Y.all([Dt(H,o,dt,M(ve),W,z),c&&Dt(H,o,dt,M(Ft),w,z,d)])}catch{}return vs(dt)};return Be(Rt(Y.all([T.response(),T.headers()]),([K,X])=>(_t(k,o),J(q(K,A),X)),K=>(_t(k,o),tt(x)?J(x(K,A),v,E):ms(K))),()=>{Q(A)})},fromCache:()=>s}}const Ae=(t,e)=>()=>{const s=e.indexOf(t);s>=0&&e.splice(s,1)};class nt{constructor(e,s,n,a,i){this.dhs=[],this.uhs=[],this.fromCache=v;const r=()=>{r.a()};r.a=et;const l=this,f=cs(s);l.abort=r,l.baseURL=f.baseURL||"",l.url=n,l.type=e,l.context=s;const g={},o="cacheFor",c=me(f[o])?f[o][e]:v,d=a&&a.hitSource;lt(["timeout","shareRequest"],p=>{f[p]!==v&&(g[p]=f[p])}),c!==v&&(g[o]=c),d&&(l.hitSource=it(Pt(d)?d:[d],p=>ft(p,nt)?st(p):p),_t(a,"hitSource")),l.config={...g,headers:{},params:{},...a||{}},l.data=i,l.meta=a?a.meta:l.meta,l.key=l.generateKey()}onDownload(e){return at(this.dhs,e),Ae(e,this.dhs)}onUpload(e){return at(this.uhs,e),Ae(e,this.uhs)}send(e=E){const s=this,{response:n,onDownload:a,onUpload:i,abort:r,fromCache:l}=Ds(s,e);return L(s.dhs)>0&&a((f,g)=>lt(s.dhs,o=>o({loaded:f,total:g}))),L(s.uhs)>0&&i((f,g)=>lt(s.uhs,o=>o({loaded:f,total:g}))),s.abort.a=r,s.fromCache=v,s.promise=Rt(n(),f=>(s.fromCache=l(),f)),s.promise}setName(e){qt(this).name=e}generateKey(){return rs(this)}then(e,s){return Rt(this.send(),e,s)}catch(e){return Lt(this.send(),e)}finally(e){return Be(this.send(),e)}}const Xt=Nt(),vt="success",As=()=>{let t={};const e=fe();return{set(n,a){t[n]=a,e.emit(vt,{type:"set",key:n,value:a,container:t})},get:n=>{const a=t[n];return e.emit(vt,{type:"get",key:n,value:a,container:t}),a},remove(n){_t(t,n),e.emit(vt,{type:"remove",key:n,container:t})},clear:()=>{t={},e.emit(vt,{type:"clear",key:"",container:t})},emitter:e}},gt=()=>(Xt(typeof localStorage<"u","l2Cache is not defined."),localStorage),qs=()=>{const t=fe();return{set:(s,n)=>{gt().setItem(s,ls(n)),t.emit(vt,{type:"set",key:s,value:n,container:gt()})},get:s=>{const n=gt().getItem(s),a=n&&is(n);return t.emit(vt,{type:"get",key:s,value:a,container:gt()}),a},remove:s=>{gt().removeItem(s),t.emit(vt,{type:"remove",key:s,container:gt()})},clear:()=>{gt().clear(),t.emit(vt,{type:"clear",key:"",container:gt()})},emitter:t}},qe=Set;class Ns{constructor(e){this.records={},this.occupy=0,Xt(e>=0,"expected snapshots limit to be >= 0"),this.capacity=e}save(e){const{name:s}=qt(e),{records:n,occupy:a,capacity:i}=this;s&&a<i&&((n[s]=n[s]||D(qe)).add(e),this.occupy+=1)}match(e,s=!0){let n,a,i,r=e;me(e)&&(r=e.name,i=e.filter),ft(r,ge)?a=r:ds(r)&&(n=r);const{records:l}=this;let f=D(qe);n?f=l[n]||f:a&&lt(Et(xt(l),o=>a.test(o)),o=>{l[o].forEach(c=>f.add(c))});const g=tt(i)?Et([...f],i):[...f];return s?g:g[0]}}const je="GET",Hs="HEAD",Vs="POST",Ws="PUT",zs="PATCH",Os="DELETE",Bs="OPTIONS",Ne={cacheFor:{[je]:3e5},shareRequest:P,snapshots:1e3};let Gs=0;class Qs{constructor(e){var s,n;const a=this;a.id=(e.id||(Gs+=1)).toString(),a.l1Cache=e.l1Cache||As(),a.l2Cache=e.l2Cache||qs(),a.options={...Ne,...e},a.snapshots=D(Ns,(n=(s=e.snapshots)!==null&&s!==void 0?s:Ne.snapshots)!==null&&n!==void 0?n:0)}Get(e,s){return D(nt,je,this,e,s)}Post(e,s,n){return D(nt,Vs,this,e,n,s)}Delete(e,s,n){return D(nt,Os,this,e,n,s)}Put(e,s,n){return D(nt,Ws,this,e,n,s)}Head(e,s){return D(nt,Hs,this,e,s)}Patch(e,s,n){return D(nt,zs,this,e,n,s)}Options(e,s){return D(nt,Bs,this,e,s)}}let At=v;const Qt=[],$t=[],ra=t=>{const e=D(Qs,t),s=e.options.statesHook;At&&Xt(At===s,"expected to use the same `statesHook`"),At=s;const{l1Cache:n,l2Cache:a}=e;return!Qt.includes(n)&&at(Qt,n),!$t.includes(a)&&at($t,a),e},Ie=()=>(Xt(!!At,"`statesHook` is not set in alova instance"),At);var ia={name:"Vue",create:t=>Ms(t),dehydrate:t=>t.value,update:(t,e)=>{e.value=t},effectRequest({handler:t,removeStates:e,immediate:s,watchingStates:n}){se()&&Fe(e),s&&t(),lt(n||[],(a,i)=>{Ke(a,()=>{t(i)},{deep:P})})},computed:t=>_s(t),watch:(t,e)=>{Ke(t,e,{deep:P})},onMounted:t=>{se()?bs(t):Ge(t,10)},onUnmounted:t=>{se()&&Fe(t)}};const $s=(t,e)=>{let s=xs;return function(...a){const i=t.bind(this,...a),r=pt(e)?e:e(...a);s&&Es(s),r>0?s=Ge(i,r):i()}},Ys=(t,e)=>{const s={};for(const n in t)s[n]=e(t[n],n,t);return s};var ut;(function(t){t[t.USE_REQUEST=1]="USE_REQUEST",t[t.USE_WATCHER=2]="USE_WATCHER",t[t.USE_FETCHER=3]="USE_FETCHER"})(ut||(ut={}));function ke(t,e={trackedKeys:{},bindError:E}){const s=o=>t.ref?t.ref(o):{current:o};e=s(e).current;const n=o=>(t.export||ne)(o,e),a=o=>{if(!tt(t.memorize))return o;const c=t.memorize(o);return c.memorized=!0,c},{dehydrate:i}=t,r=(o,c,d)=>o!==i(c,d,e)&&e.trackedKeys[d]&&t.update(o,c,d,e),l=o=>it(o,c=>ft(c,zt)?c.e:c),f=[],g={};return{create:(o,c)=>(at(f,c),D(Te,t.create(o,c,e),c,d=>i(d,c,e),n,(d,p)=>r(p,d,c))),computed:(o,c,d)=>(lt(c,p=>{p.k&&(g[p.k]=!0)}),D(zt,t.computed(o,l(c),d,e),d,p=>i(p,d,e),n)),effectRequest:o=>t.effectRequest(o,e),ref:s,watch:(o,c)=>t.watch(l(o),c,e),onMounted:o=>t.onMounted(o,e),onUnmounted:o=>t.onUnmounted(o,e),memorize:a,__referingObj:e,exposeProvider:o=>{const c={},d={};for(const w in o){const b=o[w];if(tt(b)&&!e.trackedKeys[w])c[w]=w.startsWith("on")?(...z)=>(b(...z),W):b.memorized?b:a(b);else{const z=ft(b,zt);z&&(d[w]=b.s),Ps.defineProperty(c,w,{get:()=>(e.trackedKeys[w]=P,z?b.e:b),set:et,enumerable:P,configurable:P})}}const{update:p,__proxyState:M}=c;e.trackedKeys={...g},e.bindError=E;const H={__referingObj:e,update:a(w=>{xt(w).forEach(b=>{Bt(f,b)?r(w[b],d[b],b):b in c&&tt(p)&&p({[b]:w[b]})})}),__proxyState:a(w=>Bt(f,w)&&ft(o[w],zt)?(e.trackedKeys[w]=P,o[w]):M(w))},W=Vt(c,H);return W},objectify:(o,c)=>o.reduce((d,p)=>(d[p.k]=c?p[c]:p,d),{}),transformState2Proxy:(o,c)=>D(Te,o,c,d=>i(d,c,e),n,(d,p)=>r(p,d,c))}}const Js=Nt("useRequest"),ts=Nt("useWatcher"),es=Nt("useFetcher"),ss=t=>({[ut.USE_REQUEST]:Js,[ut.USE_WATCHER]:ts,[ut.USE_FETCHER]:es})[t],as=(t,e)=>t(ft(e,nt),"expected a method instance."),de="success",ue="error",he="complete";var Xs=(t,e,s,n)=>({m:v,sf:[],rf:[],fs:{},em:s,ht:t,c:e,ro:n,ms:{}});class Mt{constructor(e,s){this.method=e,this.args=s}clone(){return{...this}}static spawn(e,s){return new Mt(e,s)}}class Zs extends Mt{constructor(e,s,n){super(e.method,e.args),this.data=s,this.fromCache=n}}class js extends Mt{constructor(e,s){super(e.method,e.args),this.error=s}}class He extends Mt{constructor(e,s,n,a,i){super(e.method,e.args),this.status=s,this.data=n,this.fromCache=s==="error"?!1:a,this.error=i}}const Is=(t,e)=>e(),Yt={},ks=(t,e)=>(Yt[t]||{})[e]||{},ta=(t,e,s,n)=>{const a=Yt[t]=Yt[t]||{};a[e]={s,h:n}},ea=(t,e)=>{const s=Yt[t];s&&_t(s,e)};function pe(t,e,s=[]){const n=ss(t.ht);let a=Qe(e,n,s);const{fs:i,ht:r,c:l,ms:f}=t,{loading:g,data:o,error:c}=i,d=r===ut.USE_FETCHER,{force:p=E,middleware:M=Is}=l,H=St(a),{id:W}=H,w=st(a),{abortLast:b=P}=l,ot=!t.m;return t.m=a,(async()=>{let z=et,Z=et,A=E,I=Ye(v),R=et,_=et;const y=await le(a);let U=()=>!!y,ct=E;d||(Z=x=>ta(W,w,x,t),Z({...i,...f}),z=()=>ea(W,w));const V=x=>{A=P;const{force:Q=p,method:J=a}=x||{},K=$e(Q,[D(Mt,a,s)]),X=dt=>({loaded:Ct,total:yt})=>{i[dt].v={loaded:Ct,total:yt}};a=J,at(t.sf,Z),at(t.rf,z),ct||(g.v=!!K||!y);const{downloading:j,uploading:ht}=t.ro.trackedKeys;return R=j?a.onDownload(X("downloading")):R,_=ht?a.onUpload(X("uploading")):_,I=a.send(K),U=()=>a.fromCache||E,I},mt={method:a,cachedResponse:y,config:l,abort:()=>a.abort()},k=()=>r!==ut.USE_WATCHER||!b||t.m===a,G=(x=P)=>{x&&ot&&(g.v=E),ct=x},S=M(d?{...mt,args:s,fetch:(x,...Q)=>(as(n,x),pe(t,x,Q)),proxyStates:ws(i,"data"),controlLoading:G}:{...mt,args:s,send:(...x)=>pe(t,e,x),proxyStates:i,controlLoading:G},V);let T=v;const q=Mt.spawn(a,s);try{const x=await S,Q=J=>{if(!d)k()&&(o.v=J);else if(t.c.updateState!==E){const K=ks(W,w).s;K&&(K.data.v=J)}return k()&&(c.v=v,!ct&&(g.v=E),t.em.emit(de,D(Zs,q,J,U())),t.em.emit(he,D(He,q,de,J,U(),v))),J};T=x!==v?Q(x):A?await Rt(I,Q,()=>Q(v)):v,!A&&!ct&&(g.v=E)}catch(x){throw k()&&(c.v=x,!ct&&(g.v=E),t.em.emit(ue,D(js,q,x)),t.em.emit(he,D(He,q,ue,v,U(),x))),x}return R(),_(),T})()}const Ve=t=>t.current;function Ce(t,e,s,n,a=E,i,r=0){var l;s={...s};const{__referingObj:f={trackedKeys:{},bindError:E}}=s;let g=!!a,o=v;if(a)try{const S=Qe(e,ss(t)),T=St(S),q=T.l1Cache.get(Jt(T.id,st(S)));if(q&&!ft(q,Y)){const[Q,J]=q;(!J||J>Kt())&&(o=Q)}g=!!$e((l=s.force)!==null&&l!==void 0?l:E)||!o}catch{}const{create:c,effectRequest:d,ref:p,objectify:M,exposeProvider:H,transformState2Proxy:W}=ke(Ie(),f),w={total:0,loaded:0},{managedStates:b={}}=s,ot=Ys(b,(S,T)=>W(S,T)),z=c(o??(tt(n)?n():n),"data"),Z=c(g,"loading"),A=c(v,"error"),I=c({...w},"downloading"),R=c({...w},"uploading"),_=M([z,Z,A,I,R]),y=fe(),U=Ve(p(Xs(t,s,y,f)));U.fs=_,U.em=y,U.c=s,U.ms=ot;const ct=i!==v,V=(S=e,T)=>pe(U,S,T),mt=Ve(p(Cs())),k=(S=f,T)=>{mt(()=>{Lt(V(T),q=>{if(!S.bindError&&!S.trackedKeys.error)throw q})})},G=p($s((S,T,q)=>k(T,q),S=>pt(S)?Pt(r)?r[S]:r:0));return Se.ssr||d({handler:ct?S=>G.current(S,f,e):()=>k(f),removeStates:()=>lt(U.rf,S=>S()),saveStates:S=>lt(U.sf,T=>T(S)),frontStates:{..._,...ot},watchingStates:i,immediate:a??P}),H({...M([z,Z,A,I,R]),abort:()=>U.m&&U.m.abort(),send:(S,T)=>V(T,S),onSuccess(S){y.on(de,S)},onError(S){f.bindError=P,y.on(ue,S)},onComplete(S){y.on(he,S)}})}function sa(t={}){const e=Ce(ut.USE_FETCHER,et,t),{send:s}=e;return _t(e,"send"),Vt(e,{fetch:(n,...a)=>(as(es,n),s(a,n))})}function la(t,e={}){const{immediate:s=P,initialData:n}=e,a=Ce(ut.USE_REQUEST,t,e,n,!!s),{send:i}=a;return Vt(a,{send:(...r)=>i(r)})}function aa(t,e,s={}){ts(e&&L(e)>0,"expected at least one watching state");const{immediate:n,debounce:a=0,initialData:i}=s,r=Ce(ut.USE_WATCHER,t,s,i,!!n,e,a),{send:l}=r;return Vt(r,{send:(...f)=>l(f)})}var na=t=>{let e={};return{snapshots:()=>e,save(s,n=E){const a=st(s);(!e[a]||n)&&(e[a]={entity:s})},get:s=>e[st(ft(s,nt)?s:t(s))],remove(s){s?delete e[s]:e={}}}};const Ut=Nt("usePagination"),We=(t,e)=>Ut(pt(t)&&t<L(e),"index must be a number that less than list length"),ze=t=>[t[t.length-2],t[t.length-1],t.slice(0,t.length-2)];var da=(t,e={})=>{const{create:s,computed:n,ref:a,watch:i,exposeProvider:r,objectify:l,__referingObj:f}=ke(Ie()),{preloadPreviousPage:g=P,preloadNextPage:o=P,total:c=u=>u.total,data:d=u=>u.data,append:p=E,initialPage:M=1,initialPageSize:H=10,watchingStates:W=[],initialData:w,immediate:b=P,middleware:ot,force:z=et,...Z}=e,A=a(t),I=a(E),R=s(M,"page"),_=s(H,"pageSize"),y=s(w?d(w)||[]:[],"data"),U=s(w?c(w):v,"total"),{snapshots:ct,get:V,save:mt,remove:k}=a(na(u=>A.current(u,_.v))).current,G=u=>d(u)||u,S=sa({__referingObj:f,updateState:E,force:({args:u})=>u[L(u)-1]}),{loading:T,fetch:q,abort:x,onSuccess:Q}=S,J=a(T),K=(u=R.v,h=[])=>{const m=t(u,_.v,...h);return mt(m),m};i(W,()=>{R.v=M,I.current=P});const X=a({}),j=n(()=>{const u=U.v;return u!==v?Math.ceil(u/_.v):v},[_,U],"pageCount"),ht=u=>(...h)=>X.current[u](...h),dt=aa((...u)=>{const[h,,m]=ze(u);return K(h,m)},[...W,R.e,_.e],{__referingObj:f,immediate:b,initialData:w,managedStates:l([y,R,_,U],"s"),middleware(u,h){return ot?ot({...u,delegatingActions:{refresh:ht("refresh"),insert:ht("insert"),remove:ht("remove"),replace:ht("replace"),reload:ht("reload"),getState:m=>({page:R,pageSize:_,data:y,pageCount:j,total:U,isLastPage:Zt})[m].v}},h):h()},force:u=>u.args[1]||(tt(z)?z(u):z),...Z}),{send:Ct}=dt,yt=dt.__proxyState("data"),ye=async u=>{const{rawData:h=yt.v,preloadPage:m,fetchMethod:C,forceRequest:F=E,isNextPage:N=E}=u,O=j.v,$=O?m>O:N?L(G(h))<_.v:E;if(!(m>0&&!$))return E;const{e:B}=Ht(C),rt=await le(C);return B(ve)<=Kt()?E:F||!rt},we=async(u,h,m=[])=>{const C=R.v+1,F=K(C,m);o&&await ye({rawData:u,preloadPage:C,fetchMethod:F,isNextPage:P,forceRequest:h})&&Lt(q(F,...m,h),et)},ns=async(u,h=[])=>{const m=R.v-1,C=K(m,h);g&&await ye({rawData:u,preloadPage:m,fetchMethod:C})&&Lt(q(C,...h,v),et)},Zt=n(()=>{const u=yt.v;if(!u)return P;const h=G(u),m=R.v,C=j.v,F=Pt(h)?L(h):0;return C?m>=C:F<_.v},[R,j,yt,_],"isLastPage"),jt=async()=>{const u=V(R.v);u&&await ae(u.entity,h=>{if(h){const m=G(h)||[];return bt(m,0,L(m),...y.v),h}})};Q(({method:u,data:h})=>{const m=V(R.v);if(m&&st(m.entity)===st(u)){const C=G(h);if(p){const F=y.v,N=_.v,O=L(F)%N;if(O>0){const $=[...y.v];bt($,(R.v-1)*N,O,...C),y.v=$}}else y.v=C}});const It=a(v),kt=a(v);dt.onSuccess(({data:u,args:h,method:m})=>{const[C,F,N]=ze(h),{total:O}=V(m)||{},$=u;U.v=O!==v?O:c($),F||(ns($,N),we($,E,N));const wt=_.v,B=G($);if(Ut(Pt(B),"Got wrong array, did you return the correct array of list in `data` function"),p){if(I.current&&(y.v=[]),C===v)y.v=[...y.v,...B];else if(C){const rt=[...y.v];bt(rt,(C-1)*wt,wt,...B),y.v=rt}}else y.v=B}).onSuccess(({data:u})=>{var h;(h=It.current)===null||h===void 0||h.call(It,u)}).onError(({error:u})=>{var h;(h=kt.current)===null||h===void 0||h.call(kt,u)}).onComplete(()=>{I.current=E});const Wt=u=>{const h=y.v.indexOf(u);return Ut(h>=0,"item is not found in list"),h},{addQueue:te,onComplete:Re}=a(Ss()).current,ee=async(u=R.v)=>{let h=u,m=Ye();if(p){if(!pt(u)){const C=Wt(u);h=Math.floor(C/_.v)+1}Ut(h<=R.v,"refresh page can't greater than page"),m=Ct(h,P)}else Ut(pt(h),"unable to calculate refresh page by item in pagination mode"),m=h===R.v?Ct(v,P):q(t(h,_.v),P);return m},Ee=async(u=E)=>{const h=R.v,m=ct();let C=Rs(m);if(u)k();else{const F=it(Et([V(h-1),V(h),V(h+1)],Boolean),({entity:N})=>st(N));C=it(Et(xt(m),N=>!Bt(F,N)),N=>{const O=m[N];return delete m[N],O})}await Ks(it(C,({entity:F})=>F))},xe=async()=>{J.current&&x(),await Ee();const u=V(R.v+1);if(u){const h=G(await le(u.entity)||{})||[];we(v,L(h)<_.v)}},Pe=u=>{if(u===0)return;const h=U.v;if(pt(h)){const m=Math.max(h+u,0);U.v=m;const C=R.v;lt([V(C-1),V(C),V(C+1)],F=>{F&&(F.total=m)})}},_e=(u,h=0)=>(Re(xe),te(async()=>{const m=pt(h)?h:Wt(h)+1;let C=v;const F=[...y.v];if(L(F)%_.v===0&&(C=F.pop()),bt(F,m,0,u),y.v=F,Pe(1),await jt(),C){const N=V(R.v+1);N&&await ae(N.entity,O=>{if(O){const $=G(O)||[];return $.unshift(C),$.pop(),O}})}})),Me=(...u)=>(Re(xe),te(async()=>{const h=it(u,B=>{const rt=pt(B)?B:Wt(B);return We(rt,y.v),rt}),m=R.v,C=m+1,F=V(C),N=[];F&&await ae(F.entity,B=>{if(B){const rt=G(B);return Pt(rt)&&at(N,...bt(rt,0,L(h))),B}});const O=Zt.v,$=L(N);let wt=!1;if($>0||O){const B=Et(y.v,(rt,os)=>!Bt(h,os));wt=!p&&O&&L(B)<=0,!wt&&$>0&&at(B,...N),y.v=B}else $<=0&&!O&&ee(m);return Pe(-L(h)),jt().then(()=>{wt&&(R.v=m-1)})})),be=(u,h)=>te(async()=>{Ut(h!==v,"expect specify the replace position");const m=pt(h)?h:Wt(h);We(m,y.v);const C=[...y.v];bt(C,m,1,u),y.v=C,await jt()}),Ue=async()=>{await Ee(P),I.current=P,R.v===M?Lt(Ct(),et):R.v=M;const{resolve:u,reject:h,promise:m}=ys();return It.current=u,kt.current=h,m};return X.current={refresh:ee,insert:_e,remove:Me,replace:be,reload:Ue},r({...dt,...l([y,R,j,_,U,Zt]),send:(...u)=>Ct(...u,v,v),fetching:S.loading,onFetchSuccess:S.onSuccess,onFetchError:S.onError,onFetchComplete:S.onComplete,refresh:ee,insert:_e,remove:Me,replace:be,reload:Ue})},Oe;(function(t){t[t.CONNECTING=0]="CONNECTING",t[t.OPEN=1]="OPEN",t[t.CLOSED=2]="CLOSED"})(Oe||(Oe={}));export{da as a,ra as c,la as u,ia as v};
